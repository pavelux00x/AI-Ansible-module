#!/usr/bin/python
import os
import requests
import base64
import json
from ansible.module_utils.basic import AnsibleModule

# Copyright: (c) 2018, Terry Jones <terry.jones@example.org>
# GNU General Public License v3.0+ (see COPYING or https://www.gnu.org/licenses/gpl-3.0.txt)
ENDPOINT = "https://ansible.openai.azure.com/openai/deployments/pavel-ansible/chat/completions?api-version=2024-02-15-preview"


ANSIBLE_METADATA = {
    'metadata_version': '1.1',
    'status': ['preview'],
    'supported_by': 'community'
}

DOCUMENTATION = '''
---
module: azure_openai

short_description: Generate Linux commands via an API call to Azure OpenAI.

version_added: "2.4"

description:
    - This module sends a task description to Azure OpenAI and returns a corresponding Linux command.
    - Designed to work with Ansible for automation tasks, this ensures that responses are formatted correctly for Ansible playbooks.

options:
    api_key:
        description:
            - The API key for the Azure OpenAI service.
        required: true
    message:
        description:
            - The task description to be sent to the API for command generation.
        required: true

author:
    - Your Name (@levap00x)
'''
EXAMPLES = '''
# Send a task description and retrieve a Linux command
- name: Generate command for directory creation
  my_test:
    api_key: "{{ api_key }}"
    message: "Create a directory called test"

# Fail if something goes wrong
- name: Test failure of the module
  my_test:
    api_key: "{{ api_key }}"
    message: "fail me"
'''



RETURN = '''
original_message:
    description: The original task description that was passed in.
    type: str
    returned: always
response_message:
    description: The command generated by the API based on the task description.
    type: str
    returned: always
'''


def run_module():
    # define available arguments/parameters a user can pass to the module
    module_args = dict(
        api_key=dict(type='str', required=True),
        message=dict(type='str', required=True)
    )

    # seed the result dict in the object
    # we primarily care about changed and state
    # changed is if this module effectively modified the target
    # state will include any data that you want your module to pass back
    # for consumption, for example, in a subsequent task
    result = dict(
        changed=False,
        message=''
    )

    # the AnsibleModule object will be our abstraction working with Ansible
    # this includes instantiation, a couple of common attr would be the
    # args/params passed to the execution, as well as if the module
    # supports check mode
    module = AnsibleModule(
        argument_spec=module_args,
        supports_check_mode=True
    )

    # if the user is working with this module in only check mode we do not
    # want to make any changes to the environment, just return the current
    # state with no modifications
    if module.check_mode:
        module.exit_json(**result)

    # manipulate or modify the state as needed (this is going to be the
    # part where your module will do what it needs to do)
    result['message'] = call_openai_api(module.params['api_key'], module.params['message'])
    

    # use whatever logic you need to determine whether or not this module
    # made any modifications to your target


    # during the execution of the module, if there is an exception or a
    # conditional state that effectively causes a failure, run
    # AnsibleModule.fail_json() to pass in the message and the result


    # in the event of a successful module execution, you will want to
    # simple AnsibleModule.exit_json(), passing the key/value results
    module.exit_json(**result)



def call_openai_api(api_key, message):
    HEADERS = {
        'Content-Type': 'application/json',
        'api-key': api_key
    }
    payload = {
        "messages": [
            {
                "role": "system",
                "content": [
                    {
                        "type": "text",
                        "text": "Given the prompt I provide you, your task is to return to me only the Linux command necessary to execute what I requested. For example, if I tell you 'create a directory called test', your response should just be mkdir test, with no further explanation or additional output. Always respond only with the command necessary to complete my request. I need to run the command on an ansible module, so be careful about the quotes and quotes. You don't have to give me the ansible command but the bash command that I have to run on ansible. You must be sure that the command will work on the ansible module. If you have any questions, please let me know."
                    }
                ]
            },
            {
                "role": "user",
                "content": [
                    {
                        "type": "text",
                        "text": message
                    }
                ]
            }
        ],
        "temperature": 0.5,
        "top_p": 0.95,
        "max_tokens": 800
    }
    
    try:
        response = requests.post(ENDPOINT, headers=HEADERS, json=payload)
        response.raise_for_status() 
        response_message = response.json()['choices'][0]['message']['content']
        return response_message 
    except requests.RequestException as e:
        raise SystemExit(f"Failed to make the request. Error: {e}")
    
def main():
    run_module()

if __name__ == '__main__':
    main()
